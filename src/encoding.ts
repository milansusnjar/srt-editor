/**
 * Detect encoding of a byte buffer.
 * Supports: UTF-16 BE, UTF-16 LE, UTF-8, Windows-1251 (Cyrillic), Windows-1250 (Central European).
 */
export function detectEncoding(bytes: Uint8Array): string {
  // UTF-16 BE BOM
  if (bytes.length >= 2 && bytes[0] === 0xfe && bytes[1] === 0xff) {
    return "utf-16be";
  }

  // UTF-16 LE BOM
  if (bytes.length >= 2 && bytes[0] === 0xff && bytes[1] === 0xfe) {
    return "utf-16le";
  }

  // UTF-8 BOM
  if (bytes.length >= 3 && bytes[0] === 0xef && bytes[1] === 0xbb && bytes[2] === 0xbf) {
    return "utf-8";
  }

  // Valid UTF-8 byte sequences
  if (isValidUtf8(bytes)) {
    return "utf-8";
  }

  // Not valid UTF-8 — distinguish Windows-1250 vs Windows-1251
  return detect1250vs1251(bytes);
}

function isValidUtf8(bytes: Uint8Array): boolean {
  let i = 0;
  let hasHighBytes = false;

  while (i < bytes.length) {
    const b = bytes[i];

    if (b <= 0x7f) {
      // ASCII — always valid
      i++;
      continue;
    }

    hasHighBytes = true;

    // Multi-byte UTF-8 sequences
    let seqLen: number;
    if ((b & 0xe0) === 0xc0) seqLen = 2;
    else if ((b & 0xf0) === 0xe0) seqLen = 3;
    else if ((b & 0xf8) === 0xf0) seqLen = 4;
    else return false; // Invalid leading byte

    if (i + seqLen > bytes.length) return false;

    for (let j = 1; j < seqLen; j++) {
      if ((bytes[i + j] & 0xc0) !== 0x80) return false; // Invalid continuation byte
    }

    i += seqLen;
  }

  // If all bytes are ASCII, treat as UTF-8 (compatible)
  if (!hasHighBytes) return true;

  return true;
}

/**
 * Heuristic: In Windows-1251 (Cyrillic), bytes 0xC0-0xFF represent А-я (core alphabet),
 * making up ~40-60% of non-whitespace content. In Windows-1250 (Central European),
 * accented characters in 0xC0-0xFF are typically <10%.
 * Threshold: 20% → above = 1251, below = 1250.
 */
function detect1250vs1251(bytes: Uint8Array): string {
  let highBytes = 0;
  let nonWhitespace = 0;

  for (let i = 0; i < bytes.length; i++) {
    const b = bytes[i];
    // Skip whitespace (space, tab, CR, LF)
    if (b === 0x20 || b === 0x09 || b === 0x0d || b === 0x0a) continue;
    nonWhitespace++;
    if (b >= 0xc0 && b <= 0xff) highBytes++;
  }

  if (nonWhitespace === 0) return "windows-1250";

  const ratio = highBytes / nonWhitespace;
  return ratio > 0.2 ? "windows-1251" : "windows-1250";
}

export function decode(bytes: Uint8Array, encoding: string): string {
  return new TextDecoder(encoding).decode(bytes);
}

/**
 * Encode a string back to the given encoding.
 * TextEncoder only supports UTF-8, so for single-byte and UTF-16 encodings we handle manually.
 */
export function encode(text: string, encoding: string): Uint8Array {
  if (encoding === "utf-8") {
    return new TextEncoder().encode(text);
  }

  if (encoding === "utf-16le" || encoding === "utf-16be") {
    return encodeUtf16(text, encoding);
  }

  if (encoding === "windows-1251") {
    return encodeSingleByte(text, unicodeToWin1251);
  }

  // Default: windows-1250
  return encodeSingleByte(text, unicodeToWin1250);
}

function encodeSingleByte(text: string, reverseMap: Map<number, number>): Uint8Array {
  const bytes = new Uint8Array(text.length);
  for (let i = 0; i < text.length; i++) {
    const code = text.charCodeAt(i);
    if (code <= 0x7f) {
      bytes[i] = code;
    } else {
      const mapped = reverseMap.get(code);
      bytes[i] = mapped !== undefined ? mapped : 0x3f; // '?' for unmappable
    }
  }
  return bytes;
}

function encodeUtf16(text: string, encoding: "utf-16le" | "utf-16be"): Uint8Array {
  const isLE = encoding === "utf-16le";
  // BOM (2 bytes) + 2 bytes per code unit
  const buf = new Uint8Array(2 + text.length * 2);
  // Write BOM
  buf[0] = isLE ? 0xff : 0xfe;
  buf[1] = isLE ? 0xfe : 0xff;
  for (let i = 0; i < text.length; i++) {
    const code = text.charCodeAt(i);
    const offset = 2 + i * 2;
    if (isLE) {
      buf[offset] = code & 0xff;
      buf[offset + 1] = (code >> 8) & 0xff;
    } else {
      buf[offset] = (code >> 8) & 0xff;
      buf[offset + 1] = code & 0xff;
    }
  }
  return buf;
}

// ── Windows-1250 ──

const win1250ToUnicode: Record<number, number> = {
  0x80: 0x20ac, 0x82: 0x201a, 0x84: 0x201e, 0x85: 0x2026, 0x86: 0x2020,
  0x87: 0x2021, 0x89: 0x2030, 0x8a: 0x0160, 0x8b: 0x2039, 0x8c: 0x015a,
  0x8d: 0x0164, 0x8e: 0x017d, 0x8f: 0x0179, 0x91: 0x2018, 0x92: 0x2019,
  0x93: 0x201c, 0x94: 0x201d, 0x95: 0x2022, 0x96: 0x2013, 0x97: 0x2014,
  0x99: 0x2122, 0x9a: 0x0161, 0x9b: 0x203a, 0x9c: 0x015b, 0x9d: 0x0165,
  0x9e: 0x017e, 0x9f: 0x017a, 0xa0: 0x00a0, 0xa1: 0x02c7, 0xa2: 0x02d8,
  0xa3: 0x0141, 0xa4: 0x00a4, 0xa5: 0x0104, 0xa6: 0x00a6, 0xa7: 0x00a7,
  0xa8: 0x00a8, 0xa9: 0x00a9, 0xaa: 0x015e, 0xab: 0x00ab, 0xac: 0x00ac,
  0xad: 0x00ad, 0xae: 0x00ae, 0xaf: 0x017b, 0xb0: 0x00b0, 0xb1: 0x00b1,
  0xb2: 0x02db, 0xb3: 0x0142, 0xb4: 0x00b4, 0xb5: 0x00b5, 0xb6: 0x00b6,
  0xb7: 0x00b7, 0xb8: 0x00b8, 0xb9: 0x0105, 0xba: 0x015f, 0xbb: 0x00bb,
  0xbc: 0x013d, 0xbd: 0x02dd, 0xbe: 0x013e, 0xbf: 0x017c, 0xc0: 0x0154,
  0xc1: 0x00c1, 0xc2: 0x00c2, 0xc3: 0x0102, 0xc4: 0x00c4, 0xc5: 0x0139,
  0xc6: 0x0106, 0xc7: 0x00c7, 0xc8: 0x010c, 0xc9: 0x00c9, 0xca: 0x0118,
  0xcb: 0x00cb, 0xcc: 0x011a, 0xcd: 0x00cd, 0xce: 0x00ce, 0xcf: 0x010e,
  0xd0: 0x0110, 0xd1: 0x0143, 0xd2: 0x0147, 0xd3: 0x00d3, 0xd4: 0x00d4,
  0xd5: 0x0150, 0xd6: 0x00d6, 0xd7: 0x00d7, 0xd8: 0x0158, 0xd9: 0x016e,
  0xda: 0x00da, 0xdb: 0x0170, 0xdc: 0x00dc, 0xdd: 0x00dd, 0xde: 0x0162,
  0xdf: 0x00df, 0xe0: 0x0155, 0xe1: 0x00e1, 0xe2: 0x00e2, 0xe3: 0x0103,
  0xe4: 0x00e4, 0xe5: 0x013a, 0xe6: 0x0107, 0xe7: 0x00e7, 0xe8: 0x010d,
  0xe9: 0x00e9, 0xea: 0x0119, 0xeb: 0x00eb, 0xec: 0x011b, 0xed: 0x00ed,
  0xee: 0x00ee, 0xef: 0x010f, 0xf0: 0x0111, 0xf1: 0x0144, 0xf2: 0x0148,
  0xf3: 0x00f3, 0xf4: 0x00f4, 0xf5: 0x0151, 0xf6: 0x00f6, 0xf7: 0x00f7,
  0xf8: 0x0159, 0xf9: 0x016f, 0xfa: 0x00fa, 0xfb: 0x0171, 0xfc: 0x00fc,
  0xfd: 0x00fd, 0xfe: 0x0163, 0xff: 0x02d9,
};

const unicodeToWin1250 = new Map<number, number>();
for (let i = 0xa0; i <= 0xff; i++) {
  unicodeToWin1250.set(i, i);
}
for (const [byte, unicode] of Object.entries(win1250ToUnicode)) {
  unicodeToWin1250.set(unicode, Number(byte));
}

// ── Windows-1251 ──

const win1251ToUnicode: Record<number, number> = {
  0x80: 0x0402, 0x81: 0x0403, 0x82: 0x201a, 0x83: 0x0453, 0x84: 0x201e,
  0x85: 0x2026, 0x86: 0x2020, 0x87: 0x2021, 0x88: 0x20ac, 0x89: 0x2030,
  0x8a: 0x0409, 0x8b: 0x2039, 0x8c: 0x040a, 0x8d: 0x040c, 0x8e: 0x040b,
  0x8f: 0x040f, 0x90: 0x0452, 0x91: 0x2018, 0x92: 0x2019, 0x93: 0x201c,
  0x94: 0x201d, 0x95: 0x2022, 0x96: 0x2013, 0x97: 0x2014, 0x99: 0x2122,
  0x9a: 0x0459, 0x9b: 0x203a, 0x9c: 0x045a, 0x9d: 0x045c, 0x9e: 0x045b,
  0x9f: 0x045f, 0xa0: 0x00a0, 0xa1: 0x040e, 0xa2: 0x045e, 0xa3: 0x0408,
  0xa4: 0x00a4, 0xa5: 0x0490, 0xa6: 0x00a6, 0xa7: 0x00a7, 0xa8: 0x0401,
  0xa9: 0x00a9, 0xaa: 0x0404, 0xab: 0x00ab, 0xac: 0x00ac, 0xad: 0x00ad,
  0xae: 0x00ae, 0xaf: 0x0407, 0xb0: 0x00b0, 0xb1: 0x00b1, 0xb2: 0x0406,
  0xb3: 0x0456, 0xb4: 0x0491, 0xb5: 0x00b5, 0xb6: 0x00b6, 0xb7: 0x00b7,
  0xb8: 0x0451, 0xb9: 0x2116, 0xba: 0x0454, 0xbb: 0x00bb, 0xbc: 0x0458,
  0xbd: 0x0405, 0xbe: 0x0455, 0xbf: 0x0457,
  // 0xC0-0xFF: А-я (U+0410-U+044F)
  0xc0: 0x0410, 0xc1: 0x0411, 0xc2: 0x0412, 0xc3: 0x0413, 0xc4: 0x0414,
  0xc5: 0x0415, 0xc6: 0x0416, 0xc7: 0x0417, 0xc8: 0x0418, 0xc9: 0x0419,
  0xca: 0x041a, 0xcb: 0x041b, 0xcc: 0x041c, 0xcd: 0x041d, 0xce: 0x041e,
  0xcf: 0x041f, 0xd0: 0x0420, 0xd1: 0x0421, 0xd2: 0x0422, 0xd3: 0x0423,
  0xd4: 0x0424, 0xd5: 0x0425, 0xd6: 0x0426, 0xd7: 0x0427, 0xd8: 0x0428,
  0xd9: 0x0429, 0xda: 0x042a, 0xdb: 0x042b, 0xdc: 0x042c, 0xdd: 0x042d,
  0xde: 0x042e, 0xdf: 0x042f, 0xe0: 0x0430, 0xe1: 0x0431, 0xe2: 0x0432,
  0xe3: 0x0433, 0xe4: 0x0434, 0xe5: 0x0435, 0xe6: 0x0436, 0xe7: 0x0437,
  0xe8: 0x0438, 0xe9: 0x0439, 0xea: 0x043a, 0xeb: 0x043b, 0xec: 0x043c,
  0xed: 0x043d, 0xee: 0x043e, 0xef: 0x043f, 0xf0: 0x0440, 0xf1: 0x0441,
  0xf2: 0x0442, 0xf3: 0x0443, 0xf4: 0x0444, 0xf5: 0x0445, 0xf6: 0x0446,
  0xf7: 0x0447, 0xf8: 0x0448, 0xf9: 0x0449, 0xfa: 0x044a, 0xfb: 0x044b,
  0xfc: 0x044c, 0xfd: 0x044d, 0xfe: 0x044e, 0xff: 0x044f,
};

const unicodeToWin1251 = new Map<number, number>();
for (let i = 0xa0; i <= 0xff; i++) {
  unicodeToWin1251.set(i, i);
}
for (const [byte, unicode] of Object.entries(win1251ToUnicode)) {
  unicodeToWin1251.set(unicode, Number(byte));
}
